yoastWebpackJsonp([15],{

/***/ 2058:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* global tinyMCE */\n/* global wpseoShortcodePluginL10n */\n/* global ajaxurl */\n/* global _ */\n/* global JSON */\n/* global console */\nvar shortcodeNameMatcher = \"[^<>&/\\\\[\\\\]\\x00-\\x20=]+?\";\nvar shortcodeAttributesMatcher = \"( [^\\\\]]+?)?\";\n\nvar shortcodeStartRegex = new RegExp(\"\\\\[\" + shortcodeNameMatcher + shortcodeAttributesMatcher + \"\\\\]\", \"g\");\nvar shortcodeEndRegex = new RegExp(\"\\\\[/\" + shortcodeNameMatcher + \"\\\\]\", \"g\");\n\n(function () {\n\t/**\n  * The Yoast Shortcode plugin parses the shortcodes in a given piece of text. It analyzes multiple input fields for\n  * shortcodes which it will preload using AJAX.\n  *\n  * @constructor\n  * @property {RegExp} keywordRegex Used to match a given string for valid shortcode keywords.\n  * @property {RegExp} closingTagRegex Used to match a given string for shortcode closing tags.\n  * @property {RegExp} nonCaptureRegex Used to match a given string for non capturing shortcodes.\n  * @property {Array} parsedShortcodes Used to store parsed shortcodes.\n  *\n  * @param {app} app The app object.\n  */\n\tvar YoastShortcodePlugin = function YoastShortcodePlugin(app) {\n\t\tthis._app = app;\n\n\t\tthis._app.registerPlugin(\"YoastShortcodePlugin\", { status: \"loading\" });\n\t\tthis.bindElementEvents();\n\n\t\tvar keywordRegexString = \"(\" + wpseoShortcodePluginL10n.wpseo_shortcode_tags.join(\"|\") + \")\";\n\n\t\t// The regex for matching shortcodes based on the available shortcode keywords.\n\t\tthis.keywordRegex = new RegExp(keywordRegexString, \"g\");\n\t\tthis.closingTagRegex = new RegExp(\"\\\\[\\\\/\" + keywordRegexString + \"\\\\]\", \"g\");\n\t\tthis.nonCaptureRegex = new RegExp(\"\\\\[\" + keywordRegexString + \"[^\\\\]]*?\\\\]\", \"g\");\n\n\t\tthis.parsedShortcodes = [];\n\n\t\tthis.loadShortcodes(this.declareReady.bind(this));\n\t};\n\n\t/* YOAST SEO CLIENT */\n\n\t/**\n  * Declares ready with YoastSEO.\n  *\n  * @returns {void}\n  */\n\tYoastShortcodePlugin.prototype.declareReady = function () {\n\t\tthis._app.pluginReady(\"YoastShortcodePlugin\");\n\t\tthis.registerModifications();\n\t};\n\n\t/**\n  * Declares reloaded with YoastSEO.\n  *\n  * @returns {void}\n  */\n\tYoastShortcodePlugin.prototype.declareReloaded = function () {\n\t\tthis._app.pluginReloaded(\"YoastShortcodePlugin\");\n\t};\n\n\t/**\n  * Registers the modifications for the content in which we want to replace shortcodes.\n  *\n  * @returns {void}\n  */\n\tYoastShortcodePlugin.prototype.registerModifications = function () {\n\t\tthis._app.registerModification(\"content\", this.replaceShortcodes.bind(this), \"YoastShortcodePlugin\");\n\t};\n\n\t/**\n  * Removes all unknown shortcodes. Not all plugins properly registerd their shortcodes in the WordPress backend.\n  * Since we cannot use the data from these shortcodes they must be removed.\n  *\n  * @param {string} data The text to remove unknown shortcodes.\n  * @returns {string} The text with removed unknown shortcodes.\n  */\n\tYoastShortcodePlugin.prototype.removeUnknownShortCodes = function (data) {\n\t\tdata = data.replace(shortcodeStartRegex, \"\");\n\t\tdata = data.replace(shortcodeEndRegex, \"\");\n\n\t\treturn data;\n\t};\n\n\t/**\n  * The callback used to replace the shortcodes.\n  *\n  * @param {string} data The text to replace the shortcodes in.\n  *\n  * @returns {string} The text with replaced shortcodes.\n  */\n\tYoastShortcodePlugin.prototype.replaceShortcodes = function (data) {\n\t\tvar parsedShortcodes = this.parsedShortcodes;\n\n\t\tif (typeof data === \"string\" && parsedShortcodes.length > 0) {\n\t\t\tfor (var i = 0; i < parsedShortcodes.length; i++) {\n\t\t\t\tdata = data.replace(parsedShortcodes[i].shortcode, parsedShortcodes[i].output);\n\t\t\t}\n\t\t}\n\n\t\tdata = this.removeUnknownShortCodes(data);\n\n\t\treturn data;\n\t};\n\n\t/* DATA SOURCING */\n\n\t/**\n  * Get data from inputfields and store them in an analyzerData object. This object will be used to fill\n  * the analyzer and the snippetpreview\n  *\n  * @param {function} callback To declare either ready or reloaded after parsing.\n  *\n  * @returns {void}\n  */\n\tYoastShortcodePlugin.prototype.loadShortcodes = function (callback) {\n\t\tvar unparsedShortcodes = this.getUnparsedShortcodes(this.getShortcodes(this.getContentTinyMCE()));\n\t\tif (unparsedShortcodes.length > 0) {\n\t\t\tthis.parseShortcodes(unparsedShortcodes, callback);\n\t\t} else {\n\t\t\treturn callback();\n\t\t}\n\t};\n\n\t/**\n  * Bind elements to be able to reload the dataset if shortcodes get added.\n  *\n  * @returns {void}\n  */\n\tYoastShortcodePlugin.prototype.bindElementEvents = function () {\n\t\tvar contentElement = document.getElementById(\"content\") || false;\n\t\tvar callback = _.debounce(this.loadShortcodes.bind(this, this.declareReloaded.bind(this)), 500);\n\n\t\tif (contentElement) {\n\t\t\tcontentElement.addEventListener(\"keyup\", callback);\n\t\t\tcontentElement.addEventListener(\"change\", callback);\n\t\t}\n\n\t\tif (typeof tinyMCE !== \"undefined\" && typeof tinyMCE.on === \"function\") {\n\t\t\ttinyMCE.on(\"addEditor\", function (e) {\n\t\t\t\te.editor.on(\"change\", callback);\n\t\t\t\te.editor.on(\"keyup\", callback);\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n  * Gets content from the content field, if tinyMCE is initialized, use the getContent function to\n  * get the data from tinyMCE.\n  *\n  * @returns {String} Content from tinyMCE.\n  */\n\tYoastShortcodePlugin.prototype.getContentTinyMCE = function () {\n\t\tvar val = document.getElementById(\"content\") && document.getElementById(\"content\").value || \"\";\n\t\tif (typeof tinyMCE !== \"undefined\" && typeof tinyMCE.editors !== \"undefined\" && tinyMCE.editors.length !== 0) {\n\t\t\tval = tinyMCE.get(\"content\") && tinyMCE.get(\"content\").getContent() || \"\";\n\t\t}\n\n\t\treturn val;\n\t};\n\n\t/* SHORTCODE PARSING */\n\n\t/**\n  * Returns the unparsed shortcodes out of a collection of shortcodes.\n  *\n  * @param {Array} shortcodes The shortcodes to check.\n  *\n  * @returns {Array} Array with unparsed shortcodes.\n  */\n\tYoastShortcodePlugin.prototype.getUnparsedShortcodes = function (shortcodes) {\n\t\tif ((typeof shortcodes === \"undefined\" ? \"undefined\" : _typeof(shortcodes)) !== \"object\") {\n\t\t\tconsole.error(\"Failed to get unparsed shortcodes. Expected parameter to be an array, instead received \" + (typeof shortcodes === \"undefined\" ? \"undefined\" : _typeof(shortcodes)));\n\t\t\treturn false;\n\t\t}\n\n\t\tvar unparsedShortcodes = [];\n\n\t\tfor (var i = 0; i < shortcodes.length; i++) {\n\t\t\tvar shortcode = shortcodes[i];\n\t\t\tif (unparsedShortcodes.indexOf(shortcode) === -1 && this.isUnparsedShortcode(shortcode)) {\n\t\t\t\tunparsedShortcodes.push(shortcode);\n\t\t\t}\n\t\t}\n\n\t\treturn unparsedShortcodes;\n\t};\n\n\t/**\n  * Checks if a given shortcode was already parsed.\n  *\n  * @param {string} shortcode The shortcode to check.\n  *\n  * @returns {boolean} True when shortcode is not parsed yet.\n  */\n\tYoastShortcodePlugin.prototype.isUnparsedShortcode = function (shortcode) {\n\t\tvar alreadyExists = false;\n\n\t\tfor (var i = 0; i < this.parsedShortcodes.length; i++) {\n\t\t\tif (this.parsedShortcodes[i].shortcode === shortcode) {\n\t\t\t\talreadyExists = true;\n\t\t\t}\n\t\t}\n\n\t\treturn alreadyExists === false;\n\t};\n\n\t/**\n  * Gets the shortcodes from a given piece of text.\n  *\n  * @param {string} text Text to extract shortcodes from.\n  *\n  * @returns {array} The matched shortcodes.\n  */\n\tYoastShortcodePlugin.prototype.getShortcodes = function (text) {\n\t\tif (typeof text !== \"string\") {\n\t\t\t/* jshint ignore:start */\n\t\t\tconsole.error(\"Failed to get shortcodes. Expected parameter to be a string, instead received\" + (typeof text === \"undefined\" ? \"undefined\" : _typeof(text)));\n\t\t\t/* jshint ignore:end*/\n\t\t\treturn false;\n\t\t}\n\n\t\tvar captures = this.matchCapturingShortcodes(text);\n\n\t\t// Remove the capturing shortcodes from the text before trying to match the capturing shortcodes.\n\t\tfor (var i = 0; i < captures.length; i++) {\n\t\t\ttext = text.replace(captures[i], \"\");\n\t\t}\n\n\t\tvar nonCaptures = this.matchNonCapturingShortcodes(text);\n\n\t\treturn captures.concat(nonCaptures);\n\t};\n\n\t/**\n  * Matches the capturing shortcodes from a given piece of text.\n  *\n  * @param {string} text Text to get the capturing shortcodes from.\n  *\n  * @returns {Array} The capturing shortcodes.\n  */\n\tYoastShortcodePlugin.prototype.matchCapturingShortcodes = function (text) {\n\t\tvar captures = [];\n\n\t\t// First identify which tags are being used in a capturing shortcode by looking for closing tags.\n\t\tvar captureKeywords = (text.match(this.closingTagRegex) || []).join(\" \").match(this.keywordRegex) || [];\n\n\t\t// Fetch the capturing shortcodes and strip them from the text so we can easily match the non capturing shortcodes.\n\t\tfor (var i = 0; i < captureKeywords.length; i++) {\n\t\t\tvar captureKeyword = captureKeywords[i];\n\t\t\tvar captureRegex = \"\\\\[\" + captureKeyword + \"[^\\\\]]*?\\\\].*?\\\\[\\\\/\" + captureKeyword + \"\\\\]\";\n\t\t\tvar matches = text.match(new RegExp(captureRegex, \"g\")) || [];\n\n\t\t\tcaptures = captures.concat(matches);\n\t\t}\n\n\t\treturn captures;\n\t};\n\n\t/**\n  * Matches the non capturing shortcodes from a given piece of text.\n  *\n  * @param {string} text Text to get the non capturing shortcodes from.\n  *\n  * @returns {Array}     The non capturing shortcodes.\n  */\n\tYoastShortcodePlugin.prototype.matchNonCapturingShortcodes = function (text) {\n\t\treturn text.match(this.nonCaptureRegex) || [];\n\t};\n\n\t/**\n  * Parses the unparsed shortcodes through AJAX and clears them.\n  *\n  * @param {Array} shortcodes shortcodes to be parsed.\n  * @param {function} callback function to be called in the context of the AJAX callback.\n  *\n  * @returns {void}\n  */\n\tYoastShortcodePlugin.prototype.parseShortcodes = function (shortcodes, callback) {\n\t\tif (typeof callback !== \"function\") {\n\t\t\t/* jshint ignore:start */\n\t\t\tconsole.error(\"Failed to parse shortcodes. Expected parameter to be a function, instead received \" + (typeof callback === \"undefined\" ? \"undefined\" : _typeof(callback)));\n\t\t\t/* jshint ignore:end */\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((typeof shortcodes === \"undefined\" ? \"undefined\" : _typeof(shortcodes)) === \"object\" && shortcodes.length > 0) {\n\t\t\tjQuery.post(ajaxurl, {\n\t\t\t\taction: \"wpseo_filter_shortcodes\",\n\t\t\t\t_wpnonce: wpseoShortcodePluginL10n.wpseo_filter_shortcodes_nonce,\n\t\t\t\tdata: shortcodes\n\t\t\t}, function (shortcodeResults) {\n\t\t\t\tthis.saveParsedShortcodes(shortcodeResults, callback);\n\t\t\t}.bind(this));\n\t\t} else {\n\t\t\treturn callback();\n\t\t}\n\t};\n\n\t/**\n  * Saves the shortcodes that were parsed with AJAX to `this.parsedShortcodes`\n  *\n  * @param {Array}    shortcodeResults Shortcodes that must be saved.\n  * @param {function} callback         Callback to execute of saving shortcodes.\n  *\n  * @returns {void}\n  */\n\tYoastShortcodePlugin.prototype.saveParsedShortcodes = function (shortcodeResults, callback) {\n\t\tshortcodeResults = JSON.parse(shortcodeResults);\n\t\tfor (var i = 0; i < shortcodeResults.length; i++) {\n\t\t\tthis.parsedShortcodes.push(shortcodeResults[i]);\n\t\t}\n\n\t\tcallback();\n\t};\n\n\twindow.YoastShortcodePlugin = YoastShortcodePlugin;\n})();\n\n//////////////////\n// WEBPACK FOOTER\n// ./wp-seo-shortcode-plugin.js\n// module id = 2058\n// module chunks = 15\n\n//# sourceURL=webpack:///./wp-seo-shortcode-plugin.js?");

/***/ })

},[2058]);